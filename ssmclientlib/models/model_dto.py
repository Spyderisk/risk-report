# coding: utf-8

"""
    OpenAPI definition

    SPYDERISK System Modeller (SSM) REST API definitions for domain models, user system models and usage by other applications.

    The version of the OpenAPI document: v3.5.0
    Contact: info@spyderisk.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from ssmclientlib.models.asset_dto import AssetDTO
from ssmclientlib.models.asset_group_dto import AssetGroupDTO
from ssmclientlib.models.compliance_set_dto import ComplianceSetDTO
from ssmclientlib.models.compliance_threat_dto import ComplianceThreatDTO
from ssmclientlib.models.control_set import ControlSet
from ssmclientlib.models.control_strategy_dto import ControlStrategyDTO
from ssmclientlib.models.level import Level
from ssmclientlib.models.misbehaviour_set import MisbehaviourSet
from ssmclientlib.models.relation import Relation
from ssmclientlib.models.risk_level_count import RiskLevelCount
from ssmclientlib.models.threat_dto import ThreatDTO
from ssmclientlib.models.trustworthiness_attribute_set import TrustworthinessAttributeSet
from typing import Optional, Set
from typing_extensions import Self

class ModelDTO(BaseModel):
    """
    ModelDTO
    """ # noqa: E501
    name: Optional[StrictStr] = None
    id: Optional[StrictStr] = None
    description: Optional[StrictStr] = None
    domain_graph: Optional[StrictStr] = Field(default=None, alias="domainGraph")
    domain_version: Optional[StrictStr] = Field(default=None, alias="domainVersion")
    validated_domain_version: Optional[StrictStr] = Field(default=None, alias="validatedDomainVersion")
    valid: Optional[StrictBool] = None
    risk_levels_valid: Optional[StrictBool] = Field(default=None, alias="riskLevelsValid")
    risk_calculation_mode: Optional[StrictStr] = Field(default=None, alias="riskCalculationMode")
    calculating_risks: Optional[StrictBool] = Field(default=None, alias="calculatingRisks")
    can_be_edited: Optional[StrictBool] = Field(default=None, alias="canBeEdited")
    can_be_shared: Optional[StrictBool] = Field(default=None, alias="canBeShared")
    risk: Optional[Level] = None
    threats: Optional[List[ThreatDTO]] = None
    control_strategies: Optional[Dict[str, ControlStrategyDTO]] = Field(default=None, alias="controlStrategies")
    compliance_threats: Optional[List[ComplianceThreatDTO]] = Field(default=None, alias="complianceThreats")
    compliance_sets: Optional[List[ComplianceSetDTO]] = Field(default=None, alias="complianceSets")
    misbehaviour_sets: Optional[Dict[str, MisbehaviourSet]] = Field(default=None, alias="misbehaviourSets")
    twas: Optional[Dict[str, TrustworthinessAttributeSet]] = None
    control_sets: Optional[List[ControlSet]] = Field(default=None, alias="controlSets")
    user_id: Optional[StrictStr] = Field(default=None, alias="userId")
    editor_id: Optional[StrictStr] = Field(default=None, alias="editorId")
    created: Optional[StrictInt] = None
    modified: Optional[StrictInt] = None
    modified_by: Optional[StrictStr] = Field(default=None, alias="modifiedBy")
    levels: Optional[Dict[str, List[Level]]] = None
    risk_vector: Optional[Dict[str, RiskLevelCount]] = Field(default=None, alias="riskVector")
    assets: Optional[List[AssetDTO]] = None
    relations: Optional[List[Relation]] = None
    groups: Optional[List[AssetGroupDTO]] = None
    loading_id: Optional[StrictStr] = Field(default=None, alias="loadingId")
    validating: Optional[StrictBool] = None
    __properties: ClassVar[List[str]] = ["name", "id", "description", "domainGraph", "domainVersion", "validatedDomainVersion", "valid", "riskLevelsValid", "riskCalculationMode", "calculatingRisks", "canBeEdited", "canBeShared", "risk", "threats", "controlStrategies", "complianceThreats", "complianceSets", "misbehaviourSets", "twas", "controlSets", "userId", "editorId", "created", "modified", "modifiedBy", "levels", "riskVector", "assets", "relations", "groups", "loadingId", "validating"]

    @field_validator('risk_calculation_mode')
    def risk_calculation_mode_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['CURRENT', 'FUTURE']):
            raise ValueError("must be one of enum values ('CURRENT', 'FUTURE')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ModelDTO from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of risk
        if self.risk:
            _dict['risk'] = self.risk.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in threats (list)
        _items = []
        if self.threats:
            for _item_threats in self.threats:
                if _item_threats:
                    _items.append(_item_threats.to_dict())
            _dict['threats'] = _items
        # override the default output from pydantic by calling `to_dict()` of each value in control_strategies (dict)
        _field_dict = {}
        if self.control_strategies:
            for _key_control_strategies in self.control_strategies:
                if self.control_strategies[_key_control_strategies]:
                    _field_dict[_key_control_strategies] = self.control_strategies[_key_control_strategies].to_dict()
            _dict['controlStrategies'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each item in compliance_threats (list)
        _items = []
        if self.compliance_threats:
            for _item_compliance_threats in self.compliance_threats:
                if _item_compliance_threats:
                    _items.append(_item_compliance_threats.to_dict())
            _dict['complianceThreats'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in compliance_sets (list)
        _items = []
        if self.compliance_sets:
            for _item_compliance_sets in self.compliance_sets:
                if _item_compliance_sets:
                    _items.append(_item_compliance_sets.to_dict())
            _dict['complianceSets'] = _items
        # override the default output from pydantic by calling `to_dict()` of each value in misbehaviour_sets (dict)
        _field_dict = {}
        if self.misbehaviour_sets:
            for _key_misbehaviour_sets in self.misbehaviour_sets:
                if self.misbehaviour_sets[_key_misbehaviour_sets]:
                    _field_dict[_key_misbehaviour_sets] = self.misbehaviour_sets[_key_misbehaviour_sets].to_dict()
            _dict['misbehaviourSets'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in twas (dict)
        _field_dict = {}
        if self.twas:
            for _key_twas in self.twas:
                if self.twas[_key_twas]:
                    _field_dict[_key_twas] = self.twas[_key_twas].to_dict()
            _dict['twas'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each item in control_sets (list)
        _items = []
        if self.control_sets:
            for _item_control_sets in self.control_sets:
                if _item_control_sets:
                    _items.append(_item_control_sets.to_dict())
            _dict['controlSets'] = _items
        # override the default output from pydantic by calling `to_dict()` of each value in levels (dict of array)
        _field_dict_of_array = {}
        if self.levels:
            for _key_levels in self.levels:
                if self.levels[_key_levels] is not None:
                    _field_dict_of_array[_key_levels] = [
                        _item.to_dict() for _item in self.levels[_key_levels]
                    ]
            _dict['levels'] = _field_dict_of_array
        # override the default output from pydantic by calling `to_dict()` of each value in risk_vector (dict)
        _field_dict = {}
        if self.risk_vector:
            for _key_risk_vector in self.risk_vector:
                if self.risk_vector[_key_risk_vector]:
                    _field_dict[_key_risk_vector] = self.risk_vector[_key_risk_vector].to_dict()
            _dict['riskVector'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each item in assets (list)
        _items = []
        if self.assets:
            for _item_assets in self.assets:
                if _item_assets:
                    _items.append(_item_assets.to_dict())
            _dict['assets'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in relations (list)
        _items = []
        if self.relations:
            for _item_relations in self.relations:
                if _item_relations:
                    _items.append(_item_relations.to_dict())
            _dict['relations'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in groups (list)
        _items = []
        if self.groups:
            for _item_groups in self.groups:
                if _item_groups:
                    _items.append(_item_groups.to_dict())
            _dict['groups'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ModelDTO from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "name": obj.get("name"),
            "id": obj.get("id"),
            "description": obj.get("description"),
            "domainGraph": obj.get("domainGraph"),
            "domainVersion": obj.get("domainVersion"),
            "validatedDomainVersion": obj.get("validatedDomainVersion"),
            "valid": obj.get("valid"),
            "riskLevelsValid": obj.get("riskLevelsValid"),
            "riskCalculationMode": obj.get("riskCalculationMode"),
            "calculatingRisks": obj.get("calculatingRisks"),
            "canBeEdited": obj.get("canBeEdited"),
            "canBeShared": obj.get("canBeShared"),
            "risk": Level.from_dict(obj["risk"]) if obj.get("risk") is not None else None,
            "threats": [ThreatDTO.from_dict(_item) for _item in obj["threats"]] if obj.get("threats") is not None else None,
            "controlStrategies": dict(
                (_k, ControlStrategyDTO.from_dict(_v))
                for _k, _v in obj["controlStrategies"].items()
            )
            if obj.get("controlStrategies") is not None
            else None,
            "complianceThreats": [ComplianceThreatDTO.from_dict(_item) for _item in obj["complianceThreats"]] if obj.get("complianceThreats") is not None else None,
            "complianceSets": [ComplianceSetDTO.from_dict(_item) for _item in obj["complianceSets"]] if obj.get("complianceSets") is not None else None,
            "misbehaviourSets": dict(
                (_k, MisbehaviourSet.from_dict(_v))
                for _k, _v in obj["misbehaviourSets"].items()
            )
            if obj.get("misbehaviourSets") is not None
            else None,
            "twas": dict(
                (_k, TrustworthinessAttributeSet.from_dict(_v))
                for _k, _v in obj["twas"].items()
            )
            if obj.get("twas") is not None
            else None,
            "controlSets": [ControlSet.from_dict(_item) for _item in obj["controlSets"]] if obj.get("controlSets") is not None else None,
            "userId": obj.get("userId"),
            "editorId": obj.get("editorId"),
            "created": obj.get("created"),
            "modified": obj.get("modified"),
            "modifiedBy": obj.get("modifiedBy"),
            "levels": dict(
                (_k,
                        [Level.from_dict(_item) for _item in _v]
                        if _v is not None
                        else None
                )
                for _k, _v in obj.get("levels", {}).items()
            ),
            "riskVector": dict(
                (_k, RiskLevelCount.from_dict(_v))
                for _k, _v in obj["riskVector"].items()
            )
            if obj.get("riskVector") is not None
            else None,
            "assets": [AssetDTO.from_dict(_item) for _item in obj["assets"]] if obj.get("assets") is not None else None,
            "relations": [Relation.from_dict(_item) for _item in obj["relations"]] if obj.get("relations") is not None else None,
            "groups": [AssetGroupDTO.from_dict(_item) for _item in obj["groups"]] if obj.get("groups") is not None else None,
            "loadingId": obj.get("loadingId"),
            "validating": obj.get("validating")
        })
        return _obj


